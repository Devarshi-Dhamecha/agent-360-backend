# Generated by Django 6.0.2 on 2026-02-18 13:27

import django.db.models.deletion
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('users', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='SyncLog',
            fields=[
                ('sl_id', models.AutoField(db_column='sl_id', primary_key=True, serialize=False, verbose_name='ID')),
                ('sl_run_id', models.UUIDField(db_column='sl_run_id', default=uuid.uuid4, verbose_name='Run ID')),
                ('sl_job_name', models.CharField(db_column='sl_job_name', max_length=50, verbose_name='Job Name')),
                ('sl_direction', models.CharField(db_column='sl_direction', max_length=20, verbose_name='Direction')),
                ('sl_object_name', models.CharField(db_column='sl_object_name', max_length=50, verbose_name='Object Name')),
                ('sl_sf_object_api', models.CharField(blank=True, db_column='sl_sf_object_api', max_length=50, null=True, verbose_name='SF Object API')),
                ('sl_started_at', models.DateTimeField(auto_now_add=True, db_column='sl_started_at', verbose_name='Started At')),
                ('sl_completed_at', models.DateTimeField(blank=True, db_column='sl_completed_at', null=True, verbose_name='Completed At')),
                ('sl_status', models.CharField(choices=[('running', 'Running'), ('success', 'Success'), ('partial', 'Partial'), ('failed', 'Failed'), ('skipped', 'Skipped')], db_column='sl_status', default='running', max_length=20, verbose_name='Status')),
                ('sl_records_queried', models.IntegerField(db_column='sl_records_queried', default=0, verbose_name='Records Queried')),
                ('sl_records_inserted', models.IntegerField(db_column='sl_records_inserted', default=0, verbose_name='Records Inserted')),
                ('sl_records_updated', models.IntegerField(db_column='sl_records_updated', default=0, verbose_name='Records Updated')),
                ('sl_records_deleted', models.IntegerField(db_column='sl_records_deleted', default=0, verbose_name='Records Deleted')),
                ('sl_records_skipped', models.IntegerField(db_column='sl_records_skipped', default=0, verbose_name='Records Skipped')),
                ('sl_records_failed', models.IntegerField(db_column='sl_records_failed', default=0, verbose_name='Records Failed')),
                ('sl_hwm_before', models.DateTimeField(blank=True, db_column='sl_hwm_before', null=True, verbose_name='High Water Mark Before')),
                ('sl_hwm_after', models.DateTimeField(blank=True, db_column='sl_hwm_after', null=True, verbose_name='High Water Mark After')),
                ('sl_error_message', models.TextField(blank=True, db_column='sl_error_message', null=True, verbose_name='Error Message')),
                ('sl_error_details', models.JSONField(blank=True, db_column='sl_error_details', null=True, verbose_name='Error Details')),
            ],
            options={
                'verbose_name': 'Sync Log',
                'verbose_name_plural': 'Sync Logs',
                'db_table': 'sync_log',
                'indexes': [models.Index(fields=['sl_run_id'], name='idx_sync_log_run_id'), models.Index(fields=['sl_job_name', 'sl_started_at'], name='idx_sync_log_job_started'), models.Index(fields=['sl_status'], name='idx_sync_log_status')],
                'constraints': [models.CheckConstraint(condition=models.Q(('sl_status__in', ['running', 'success', 'partial', 'failed', 'skipped'])), name='chk_sync_log_status')],
            },
        ),
        migrations.CreateModel(
            name='SyncWatermark',
            fields=[
                ('sw_id', models.AutoField(db_column='sw_id', primary_key=True, serialize=False, verbose_name='ID')),
                ('sw_object_name', models.CharField(db_column='sw_object_name', max_length=50, unique=True, verbose_name='Object Name')),
                ('sw_sf_object_api', models.CharField(db_column='sw_sf_object_api', max_length=50, verbose_name='SF Object API')),
                ('sw_last_sync_ts', models.DateTimeField(blank=True, db_column='sw_last_sync_ts', null=True, verbose_name='Last Sync Timestamp')),
                ('sw_last_delete_check', models.DateTimeField(blank=True, db_column='sw_last_delete_check', null=True, verbose_name='Last Delete Check')),
                ('sw_sync_frequency', models.CharField(choices=[('hourly', 'Hourly'), ('daily', 'Daily'), ('weekly', 'Weekly')], db_column='sw_sync_frequency', default='hourly', max_length=20, verbose_name='Sync Frequency')),
                ('sw_sync_enabled', models.BooleanField(db_column='sw_sync_enabled', default=True, verbose_name='Sync Enabled')),
                ('sw_sync_order', models.IntegerField(db_column='sw_sync_order', default=0, verbose_name='Sync Order')),
                ('sw_updated_at', models.DateTimeField(auto_now=True, db_column='sw_updated_at', verbose_name='Updated At')),
            ],
            options={
                'verbose_name': 'Sync Watermark',
                'verbose_name_plural': 'Sync Watermarks',
                'db_table': 'sync_watermarks',
                'constraints': [models.CheckConstraint(condition=models.Q(('sw_sync_frequency__in', ['hourly', 'daily', 'weekly'])), name='chk_sync_watermark_frequency')],
            },
        ),
        migrations.CreateModel(
            name='SyncConflict',
            fields=[
                ('sc_id', models.AutoField(db_column='sc_id', primary_key=True, serialize=False, verbose_name='ID')),
                ('sc_object_name', models.CharField(db_column='sc_object_name', max_length=50, verbose_name='Object Name')),
                ('sc_record_sf_id', models.CharField(db_column='sc_record_sf_id', max_length=18, verbose_name='Record SF ID')),
                ('sc_record_local_id', models.IntegerField(blank=True, db_column='sc_record_local_id', null=True, verbose_name='Record Local ID')),
                ('sc_conflict_type', models.CharField(choices=[('local_pending', 'Local Pending'), ('sf_deleted', 'SF Deleted'), ('version_mismatch', 'Version Mismatch')], db_column='sc_conflict_type', max_length=30, verbose_name='Conflict Type')),
                ('sc_local_value', models.JSONField(blank=True, db_column='sc_local_value', null=True, verbose_name='Local Value')),
                ('sc_sf_value', models.JSONField(blank=True, db_column='sc_sf_value', null=True, verbose_name='SF Value')),
                ('sc_resolution', models.CharField(blank=True, choices=[('local_wins', 'Local Wins'), ('sf_wins', 'SF Wins'), ('manual', 'Manual')], db_column='sc_resolution', max_length=20, null=True, verbose_name='Resolution')),
                ('sc_resolved_at', models.DateTimeField(blank=True, db_column='sc_resolved_at', null=True, verbose_name='Resolved At')),
                ('sc_created_at', models.DateTimeField(auto_now_add=True, db_column='sc_created_at', verbose_name='Created At')),
                ('sc_resolved_by', models.ForeignKey(blank=True, db_column='sc_resolved_by', null=True, on_delete=django.db.models.deletion.SET_NULL, to='users.user', verbose_name='Resolved By')),
            ],
            options={
                'verbose_name': 'Sync Conflict',
                'verbose_name_plural': 'Sync Conflicts',
                'db_table': 'sync_conflicts',
                'indexes': [models.Index(fields=['sc_object_name'], name='idx_sync_conflicts_object'), models.Index(fields=['sc_resolution'], name='idx_sync_conflicts_resolution')],
                'constraints': [models.CheckConstraint(condition=models.Q(('sc_conflict_type__in', ['local_pending', 'sf_deleted', 'version_mismatch'])), name='chk_sync_conflict_type'), models.CheckConstraint(condition=models.Q(('sc_resolution__in', ['local_wins', 'sf_wins', 'manual']), ('sc_resolution__isnull', True), _connector='OR'), name='chk_sync_conflict_resolution')],
            },
        ),
    ]
